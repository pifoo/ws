<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>引用类型</title>
		<script type="text/javascript" src="refer.js"> </script>
	</head>
	<body>	
		<script type="text/javascript">
         //<![CDATA[
			
			/*
			 * Object类型----------------------------------------------/
			 * 对象是某个特定引用类型的实例
			 */
			// 实例化对象有两种方式(创建Object实例)
			// 1.构造函数方式
			var person = new Object();			//创建Object引用类型的一个新实例
			person.name="Mrhe";
			
			//alert(person instanceof Object); 	//如果变量是给定引用类型(由构造函数表示)的实例,则返回true;
			
			// 2.对象字面量方式,不会调用构造函数,这种方式也是向函数传递大量可选参数的可选方式
			var person = {
				name: "Mr.He",
				age: 26
			};//或留空花括号，var person = {};person.name="Mrhe";
			//alert(person.name);
			//alert(person["name"]);//用方括号访问对象的属性时，属性应以字符串的形式放在方括号
			
			var propertyName = "name";  //将属性传给变量
			//alert(person[propertyName]) //通过变量来访问属性
			
			function displayInfo(args){
				var output = "";
				if(typeof args.name == "string"){
					output += "Name:" + args.name + "\n";
				};
				if(typeof args.age == "number"){
					output += "Age:" + args.age + "\n";
				};
				
				alert(output);
				//alert(arguments.callee.length) //返回参数个数
			};
			//displayInfo({name:"Mr.he",age:26});
			//displayInfo({name:"Mr.he"});
			//alert(displayInfo.length); // 参数个数
			
			/*
			 * Array类型
			 * 每一项可以保存任何类型的数据,大小可以动态调整---------------------------------------------/
			 */
			// 创建数组有两种方式
			// 1.构造函数方式。使用Array构造函数时，也可以省略new操作符
			var colors = new Array();//如果预先知道数组的长度，可以指定其长度，其中每一项的初始值是undefined;  var colors = new Array(20);
			// 也可以直接传递值
			// 2.数组字面量 ，不会调用构造函数
			var colors = [];	// 多个项用逗号分隔
			/*
			 *转换方法
			 */
			// 所有对象都具有toLocaleString(),toString(),valueOf()方法
			// 调用数组的toString(),valueOf()方法会返回相同的值，即由数组中每个值的字符串形式拼接而的一个以逗号分隔的字符串
			var colors = ["red","blue","green"];	// 多个项用逗号分隔
			//alert(colors) //red,blue,green  默认调用了数组每一项的toString()方法
			//alert(colors.toString()); //red,blue,green
			//alert(colors.valueOf()); //red,blue,green
			//alert(colors.toLocaleString()); //red,blue,green 
			//toLocaleString()与上面两个方法的唯一区别
			var person1={
				toLocaleString:function(){
					return "Nikolaos";
				},
				toString:function(){
					return "Nicholas";
				}
			};
			var person2={
				toLocaleString:function(){
					return "Grigorios";
				},
				toString:function(){
					return "Greg";
				}
			};
			var person = [person1,person2];
			//alert(person);//调用了每一项的toString()方法
			//alert(person.toString());
			//alert(person.toLocaleString());
			//join()方法  参数为用作分隔的字符
			//alert(person.join("--"))
			//如果数组中某一项的值为null或undefined,那么在使用
			//toLocaleString(),toString(),valueOf(),join()方法时，该值以空字符串表示
			
			//栈方法,LIFO(后进先出)  push()进栈,pop()出栈
			var colors = new Array();
			var count = colors.push("red","green");//返回数组的长度
			//alert(count) //2
			//alert(colors) //red,green
			count = colors.push("black");
			//alert(count);
			//alert(colors);
			var item = colors.pop();//取得最后一项
			//alert(item);// black
			
			//队列方法,FIFI(先进先出)  push(),shift()移出数组第一项并返回该项，同时将数组长度减1，
			//unshift()在数组的前面添加任意项，并返回最新长度
			var colors = [];
			var count = colors.push("red","green");
			count = colors.push("black");
			//alert(colors)
			var itme = colors.shift() // 取得第一项
			/*alert(itme);//red,
			alert(colors)	// green,black
			alert(colors.pop())// black 取得最后一项
			alert(colors.length)
			alert(colors) // green*/
			
			//重排序方法 reverse()反转数组项的顺序; 
			//sort()默认按升序排列数组项，该方法会调用每个数组项的toString()转型方法，然后比较得到的字符串;
			var values = [1,2,3,4,5];
			//alert(values.reverse()); // 5,4,3,2,1
			// sort()可以接收一个比较函数
			function compare(v1,v2){	//适用于大多数数据类型
				if(v1<v2){
					return -1;
				}else if(v1>v2){
					return 1;
				}else{
					return 0;
				};
				//降序只须交换比较函数返回的值即可
				//如果对数值类型或valueOf()方法返回数值类型的对象作比较
				//return v1-v2;
			};
			//使用:只要把比较函数作为参数传递给sort();
			var v = [3,54,6,7,24,6];
			//alert(v.sort(compare));
			
			//操作方法-----concat(), 	slice(start,[end]) ,	splice() 
			//1>>. concat() ,合并多个数组 。基于当前数组中的所有项创建一个新数组，
			//即该方法创建当前数组的一个副本，然后将接收到的参数添加到这个副本末尾，最后返回新构建的数组。在没传递参数的情况下，复制当前数组并返回副本
			var colors = ["red","green","blue"];
			var colors2 = colors.concat("yellow",["black","brown"]);
			//alert(colors + "\n" + colors2)
			//2>>. slice(start,[end]) ,截取数组，从指定的位置返回一个新数组
			//alert(colors.slice(1)); //green,blue
			//alert(colors2.slice(1,4)) // green,blue,yellow   不包括最后一项;如果传入的参数为负数，则为数组的长度和传入的参数相加得到的结果相同
			//3>>. splice() , 向数组的中部传入项，返回从原始数组中删除的项，如果没有删除项，则返回一个空数组 
			//a. 删除--可以删除任意数量的项，splice(0,2) //要删除的第一项，要删除的项数
			//b. 插入-- splice(起始位置,0(要删除的项数),要插入的项) // splice(2,0,"red","green")
			//c. 替换-- splice(起始位置,要删除的项数,要插入的项) // splice(2,1,"red","green")
			var colors = ["red","green","blue"];
			var removed = colors.splice(0,1);	//删除第一项
			//alert(removed)
			var removed = colors.splice(1,0,"yellow","orange");	//从位置1开始插入两项 
			//alert(removed) // [] 为空数组
			//alert(colors); // ,green,yellow,orange,blue
			removed = colors.splice(1,1,"red","purple");	//从位置1开始插入两项,删除1项
			//alert(removed) // yellow
			//alert(colors); // green,red,purple,orange,blue
			
			
			/*
			 * Date类型---------------------------------------------/
			 */
			var now = new Date();	//创建一个日期对象
			//alert(now);//Thu Jun 23 2011 01:29:56 GMT+0800 (China Standard Time)
			//document.write(now)
			Date.parse()//接收一个表示日期的字符串参数，返回相应日期的毫秒数
			//alert(Date.parse("6/23/2011"))  
			Date.UTC()
			var y2k = new Date(Date.UTC(2000,0)); //GMT时间
			y2k = new Date(2000,0) // 本地时间
			//alert(y2k);
			
			//日期格式化方法——将日期格式化为字符串
			/*toDateString();
			toTimeString();
			toLocaleDateString();
			toLocaleTimeString();
			toUTCString();*/
			
			//alert(now.getTime())//返回表示日期的毫秒数，与valueOf()方法返回的值相同
			//alert(now.getFullYear());//年
			//alert(now.getMonth() + 1); // 月分从0开始
			//alert(now.getDate());//天数
			//alert(now.getDay());//星期
			//alert(now.getHours());//时
			//alert(now.getMinutes());//分
			//alert(now.getSeconds());//秒
			//alert(now.getMilliseconds());//毫秒
			
			/*
			 * RegExp类型---------------------------------------------/
			 */
			//var expression = / pattern / flags;
			
			//var pattern1 = / patter / flags;	 正则表达式字面量方式 
			//var pattern2 = new RegExp("pattern","flags");		构造函数方式
			//RegExp实例属性
			/*global;
			multiline;
			ignoreCase;
			lastIndex;
			source;*/
			
			//参考：http://www.doc88.com/p-96414772759.html
			/*(元字符) $ ^ . [ ( | ) ] \
			 * .-它可匹配任何单字符（指定某些模式可包含任意组合的字符）
			 * ^-可指定字符串（或行）的开始
			 * $-可指定字符串（或行）的结束
			 * \-可“转义”字符，也可指定预定义集合元字符的实例
			 * |-(管道)用于交替指定与[]类似，特别用于在模式中指定“此或彼”
			 * ()-用于模式分组。
			 */
			
			/*量词：
			 * ?-出现0或1次
			 * *-出现0或多次
			 * +-出现一次或多次
			 * {n}-一定出现n次
			 * {n,m}-至少出现n次，最多出现m次
			 * {n,}-至少出现n次
			 */
			
			/*贪婪与非贪婪（惰性）的量词
			 * 贪婪匹配：
			 * ?-出现0或1次
			 * *-出现0或多次
			 * +-出现一次或多次
			 * {n}-一定出现n次
			 * {n,m}-至少出现n次，最多出现m次
			 * {n,}-至少出现n次
			 * 
			 * 非贪婪匹配：
			 * ??-
			 * *?-
			 * +?-
			 * {n}?-
			 * {n,m}?-
			 * {n,}?-
			 */
			
			/*分组，反向引用与非捕获性分组：
			 * 
			 */
			
			/*侯选
			 * 
			 */
			
			//RegExp实例方法
			/*1>>.  exec();
			接受一个要应用模式的字符串参数，然后返回包含第一个匹配项信息的数组，没有匹配到返回null;
			返回的数组虽然是Array的实例，但包含两个额外的属性：index和input;
			index 表示匹配项在字符串中的位置
			input 表示应用正则表达式的字符串*/
			var text = "mom and dad and baby";
			var pattern = /mom( and dad( and baby)?)?/gi;
			var matches = pattern.exec(text);
			//alert(matches.index); 	//0
			//alert(matches.input); 	//"mom and dad and baby"
			//alert(matches[0]);		//"mom and dad and baby"
			//alert(matches[1]);		//" and dad and baby"
			//alert(matches[2]);		//" and baby"
			//对于exec()方法而言，在不设置全局标志的情况下，在同一字符串上多次调用exec()将始终返回第一个匹配项的信息；
			//在已设置全局标志的情况下，在同一字符串上每次调用exec()则都会在字符中继续查找新匹配项的信息；
			
			/*2>>.  test();
			接受一个字符串参数，在模式与该参数匹配的情况下返回true;否则返回false;
			*/
			var text = "000-00-0000";
			var pattern = /\d{3}-\d{2}-\d{4}/;
			if(pattern.test(text)){
				//alert("模式与字符串匹配！");
			}
			//另外String对象还有一些支持正则表达式的一些方法：
			// match(),replace()
			
			/*
			 * Function类型---------------------------------------------/
			 */
			//js中,函数实际上是对象,每个函数都是Function类型的实例,
			//语法：
			//1. 函数声明方式  与位置无关
			function sun(num1,num2){
				return num1 + num2;
			}
			//2. 函数表达式方式  必须在调用前函数之前声明
			var sum = function(num1,num2){
				return num1 + num2;
			}
			//3. 构造函数方式   最后一个参数被看作为函数体
			var sum = new Function("num1","num2","return num1+num2");	// 不推荐 
			//alert(sum(10,5))
			
			//使用arguments对象模拟函数重载
			function fnTest(){
				var args = arguments;
				switch(args.length){
					case 0:
						return "没有传入参数";
					case 1:
						return "传入了参数：" + args[0];
					case 2:
						return "传入了参数：" + args[0] +  "和" + args[1];
				}
			};	// alert(fnTest());alert(fnTest(1));alert(fnTest(1,2));
			// 要访问函数的指针而不执行函数，必须去掉函数后面的圆括号
			
			//从一个函数中返回另一个函数
			//Demo:假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。要指明按照哪个属性排序 P112
			//创建比较函数，接受的参数为要作为比较的属性
			function createComparisonFunction(propertyName){
				return function(object1,object2){ 
					var value1 = object1[propertyName];
					var value2 = object2[propertyName];
					if(value1 < value2){
						return -1;
					}else if(value1 > value2){
						return 1;
					}else{
						return 0;
					}
				};
			}
			var data = [{name:"Zachary",age:28},{name:"Nicholas",age:29}];//创建包含两个对象的数组
			data.sort(createComparisonFunction("name"));
			//alert(data[0].name); //Nicholas
			data.sort(createComparisonFunction("age"));
			//alert(data[0].name); //Zachary
			
			// 函数内部属性：arguments 和 this
			// arguments,类数组对象，保存着传入函数的所有参数，还有一个属性callee,该属性是一个指向拥有
			// arguments对象的函数。
			// 阶乘
			function add(n){	//面向过程
				for(var i=ret=1;i<=n;i++){
					ret=ret*i;
				};
				alert(arguments.callee.caller);	// caller属性指向调用当前函数的那个函数
				return ret;
			};
			// function x(){alert(add(5))};x();	// 测试caller属性	
			function fnAdd(n){	
				//alert(args.callee);	// arguments对象补充:arguments对象的callee属性指向它所在的函数
				//return n ? n*fnAdd(n-1) : 1;   //函数式
				return n ? n*arguments.callee(n-1) : 1;  //递归
			};	// alert(fnAdd(5));
			// this  this引用的是函数据以此执行操作的对象--或者说是函数在执行时所处的作用域
			window.color = "red";
			var o = {color:"blue"};
			function sayColor(){
				alert(this.color);
			};//sayColor();//"red"
			o.sayColor = sayColor;
			//o.sayColor() //"blue"
			
			// 函数属性和方法  
			// 两个属性：
			// length--表示函数希望接收的命名参数的个数；
			// protorype--
			function sayName(name){alert(name);};  //alert(sayName.length)  //1
			//两个方法:非继承而来  (函数作用域 冒充)
			//这两个方法的用途都是在特定的作用域中调用函数（指定函数作用于哪个对象,即改变函数的上下文执行环境），实际上等于设置函数体内this对象的值
			// apply(作用域,参数数组)--第二个参数可以是Array的实例，也可以是arguments对象
			// call(作用域,参数数组)--第二个参数直接传递给函数的，即要逐个列举出参数
			function sum(num1,num2){return num1+num2};
			//callSum1继承了sum方法  sum的作用域为this,即为当前函数
			function callSum1(num1,num2){return sum.apply(this,arguments)}; //传入arguments对象  
			function callSum1(num1,num2){return sum.apply(this,[num1,num2])};//传入数组
			//alert(callSum1(5,10));
			function callSum(num1,num2){return sum.call(this,num1,num2)};
			//alert(callSum1(5,10));
			//主要用途是为了扩充函数懒以生存的作用域，并不仅仅是为了传递参数,
			//使用这种方式，对象与方法不需要有任何耦合关系
			//如
			window.color = "red";
			var o = {color:"blue"}
			function sayColor(){
				alert(this.color);
			}
			o.sayColor = sayColor; //将方法sayColor()添加给我o对象,和sayColor.call(o)的效果一样
			//o.sayColor();
			
			//sayColor();//red
			//sayColor.call(this);//red   <=>	o.sayColor();
			//sayColor.call(window);//red
			//sayColor.call(o);//blue
			//sayColor.apply(this);//red
			//sayColor.apply(window);//red
			//sayColor.apply(o);//blue
			//每个函数继承的toLocaleString()和toString(),valueOf()方法始终返回函数的代码 
			//每个函数都有一个非标准的caller属性，该属性指向调用当前函数的函数，一般是在一个函数内部
			//通过arguments.callee.caller来实现对调用栈的追溯。
			
			 /*
			 * 基本包装类型---------------------------------------------/
			 * 3个特殊引用类型：Boolean,Number,String
			 * 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而才能够调用一些方法来操作这些数据
			 */
			var s1 = "some text"; // 基本类型
			var s2 = s1.substring(2); //后台默认把s1转换成了包装类型，以便调用相关的属性和方法
			// alert(s2); //me text
			//相当于执行了以下过程
			var s1 = new String("some text");  //创建String类的一个实例
			var s2 = s1.substring(2);//在实例上调用指定的方法
			//alert(s2) 
			s1=null; //销毁这个实例 ,生存期~~~~~~~
			//经过此番处理，基本类型的数据就能跟对象一样使用
			/*引用类型与基本包装类型的主要区别就是对象的生存期；@@@@
			 使用new操作符实例化对象（创建引用类型的实例）——在执行流离开作用域之前一直保存在内存中
			 自动创建的基本包装类型的对象——则只存在于一行代码的执行瞬间，然后立即销毁
			  （这意味着我们不能在运行时为基本类型值添加属性和方法）
			 */
			var s1 = "some text";
			s1.color = "red";//alert(s1.color); //undefined
			var s1 = new String("some text");
			s1.color = "red"; //alert(s1.color);//red
			
			// Boolean类型
			//var booleanObject = new Boolean(true/false);
			//布尔表达式中的所有对象代表的都是true
			var falseObject = new Boolean(false);
			//alert(falseObject); //false
			var result = falseObject && true;  // 在布尔表达式中 true && true; 
			//alert(result);//true
			var falseValue = false;
			result = falseValue && true;
			//alert(result);//false
			//基本类型和引用类型的布尔值的两个区别：@@@@
			//1. typeof对基本类型的布尔值返回 boolean,对引用类型返回object
			//2. Boolean对象是Boolean类型的实例，所以 instanceof操作符测试Boolean对象返回true,而测试基本类型返回false;
			/*alert(typeof falseObject);//object
			alert(typeof falseValue);//boolean
			alert(falseObject instanceof Boolean);//true
			alert(falseValue instanceof Boolean);//false */
			
			// Number类型
			var oNumber = new Number(10);
			
			// String类型
			var oString = new String("hello world");
			// 循环调用indexOf()或lastIndexOf()来找到所有匹配的字符串
			var stringValue = "Lorem ipsum dolor sit amet,consectetur adipisicing elit";
			var positions = new Array();
			var pos = stringValue.indexOf("e");
			while(pos > -1){ //如果没找到该字符串则返回-1;
				positions.push(pos); //将搜索每次返回的字符串的位置保存到数组
				pos = stringValue.indexOf("e",pos+1);
			};
			//alert(positions);
			
			//字符串的模式匹配方法:
			//match()--本质上与调用RegExp的exec()方法相同
			//search()--返回字符串中第一个匹配项的索引，如果没有匹配项，则返回-1
			//replace()--替换子字符串
			//split()--可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中
			
			//localeCompare()--比较两个字符串：
			
			//fromCharCode()--接受一个或多个字符编码，然后将它们转换成一个字符串
			//从本质上看，与charCodeAt()执行的是相反操作
			
			 /*
			 * 内置对象---------------------------------------------/
			 * 由ECMAScript实现提供的，不依赖于宿主环境的。开发人员不必显式地实例化内置对象，因为他们已经实例化了
			 * ECMA-262定义了两个内置对象：Global和Math。 
			 */
			//URI编码方法
			//encodeURI()--用于对整个URI进行编码
			//encodeURIComponent()--用于对URI中某一段进行编码
			//它们的主要区别：encodeURI()不会对本身属于URI的特殊字符进行编码，而encodeURIComponent()则会对它发现的任何非标准字符进行编码
			//解码：decodeURI()，decodeURIComponent()
			
			//eval()方法--接受一个参数。这个方法就像一个ECMAScript解析器
			//eval("alert('hi')");等价于alert("hi");
			//eval()可以引用在包含环境中定义的变量
			var msg = "hello world";
			//eval("alert(msg)");//hello world
			//同样地，也可以在外部eval()调用中定义一个函数，然后再在该调用的外部代码中引用这个函数
			eval("function sayHi(){alert('hi');}");
			//sayHi(); //hi
			
			//Math对象111
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
         //]]>
        </script>
	
	</body>
</html>
