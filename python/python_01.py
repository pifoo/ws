#!/usr/bin/python  #coding:utf-8   # Filename : hellopython.py print '\n python基础－－－－－－－－－－－－－－－－－－－－－－－－－－－－' print 'Hello,python' #	name = raw_input('please enter your name: ') #	print 'hello,', name# print absolute value of an integer:a = 100if a >= 0:    print aelse:    print -aprint '10/3=',10/3print '10.0/3=',10.0/3print '10%3=',10%3print ord('A')print chr(65)print u'ABC'print u'ABC'.encode('utf-8')print u'\u4e2d'.encode('utf-8')# 在Python中，采用的格式化方式和C语言是一致的，用%实现# 常见的占位符有：# %d	整数# %f	浮点数# %s	字符串# %x	十六进制整数print 'Hi, %s' % 'pifoo'print 'Hi, %s, you have $%d.' % ('Michael', 1000000)## 集合	list是一种有序的集合，可以随时添加和删除其中的元素classmates = ['Michael', 'Bob', 'Tracy']print len(classmates),'\n',classmates[0]classmates.insert(1, 'Jack')print classmatesprint classmates.pop(3)print classmatesclassmates[0] = 'Pifoo'print classmates## 元组	tuple和list非常类似，但是tuple一旦初始化就不能修改t = (1,)	#只有1个元素的tuple定义时必须加一个逗号,，来消除歧义print tt = ('a', 'b', ['A', 'B'])t[2][0] = 'X't[2][1] = 'Y'print t## 条件判断# if <条件判断1>:#     <执行1># elif <条件判断2>:#     <执行2># elif <条件判断3>:#     <执行3># else:#     <执行4> age = 3if age >= 18:    print 'adult'elif age >= 6:    print 'teenager'else:    print 'kid'## 循环# for...in循环names = ['Michael', 'Bob', 'Tracy']for name in names:    print namesum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:    sum = sum + xprint sumsum = 0for x in range(101):    sum = sum + xprint sum## while循环sum = 0; n = 99while n > 0:    sum = sum + n    n = n - 2print sum## 字典 dict  使用键-值（key-value）存储d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}print d['Bob']print d.get('Bob')  # 不存在则显示Ｎone,或返回指定的值，如下print d.get('bob')print d.get('bob',-0)print 'bob' in d 	# 判断指定的key是否存在## set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key# 要创建一个set，需要提供一个list作为输入集合：s = set([1, 2, 3])print s# 重复元素在set中自动被过滤：s = set([1, 1, 2, 2, 3, 3])print s# 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果s.add(4)print ss.add(4)print ss.remove(4)print s# set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：s1 = set([1, 2, 3])s2 = set([2, 3, 4])print s1 & s2, s1 | s2# set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，# 所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”## 可变对象a = ['c', 'b', 'a']a.sort()print a# 不可变对象a = 'abc'a.replace('a', 'A')print aprint '\n python 函数－－－－－－－－－－－－－－－－－－－－－－－－－－－－' print unicode(100)## 定义函数# 求绝对值def my_abs(x):    if x >= 0:        return x    else:        return -xprint my_abs(-100)# 如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。# return None可以简写为return。# 空函数# 如果想定义一个什么事也不做的空函数，可以用pass语句：def nop():    pass 	# 占位符print nop()if age >= 18:    passdef my_abs(x):    if not isinstance(x, (int, float)):   # 参数类型检测        raise TypeError('bad operand type')    if x >= 0:        return x    else:        return -xprint my_abs(-200)# print my_abs('saf')# 返回多个值import mathdef move(x, y, step, angle=0):    nx = x + step * math.cos(angle)    ny = y - step * math.sin(angle)    return nx, ny# 同时获得返回值x, y = move(100, 100, 60, math.pi / 6)print x, yr = move(100, 100, 60, math.pi / 6)print r# x的n次方def power(x, n):    s = 1    while n > 0:        n = n - 1        s = s * x    return sprint power(5,5)## 默认参数def power(x, n=2):    s = 1    while n > 0:        n = n - 1        s = s * x    return sprint power(5)print power(5,2)def enroll(name, gender, age=6, city='Beijing'):    print 'name:', name    print 'gender:', gender    print 'age:', age    print 'city:', cityenroll('Sarah', 'F')def add_end(L=[]):    L.append('END')    return Lprint add_end([1, 2, 3])print add_end(['x', 'y', 'z'])print add_end()print add_end()   # 再次调用，错误结果，因[]是个变量记录了上次的结果# 所以，定义默认参数要牢记一点：默认参数必须指向不变对象！# 要修改上面的例子，我们可以用None这个不变对象来实现：def add_end(L=None):    if L is None:       L = []    L.append('END')    return Lprint add_end()print add_end()## 可变参数# 计算a2 + b2 + c2 + ……def calc(numbers):    sum = 0    for n in numbers:        sum = sum + n * n    return sum# 调用的时候，需要先组装出一个list或tuple：print calc([1, 2, 3])print calc((1, 3, 5, 7))# 因此，我们把函数的参数改为可变参数：def calc(*numbers):     # *    sum = 0    for n in numbers:        sum = sum + n * n    return sumprint calc(1, 2, 3)print calc(1, 3, 5, 7)# 如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：nums = [1, 2, 3]print calc(nums[0], nums[1], nums[2])# 这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，# 把list或tuple的元素变成可变参数传进去：nums = [1, 2, 3]print calc(*nums)"""## 关键字参数# 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict# 关键字参数有什么用？它可以扩展函数的功能"""def person(name, age, **kw): # **    print 'name:', name, 'age:', age, 'other:', kwperson('Michael', 30) # 传入必参person('Bob', 35, city='Beijing')	# 传入任意个数的关键字参数person('Adam', 45, gender='M', job='Engineer')#和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：kw = {'city': 'Beijing', 'job': 'Engineer'}person('Jack', 24, city=kw['city'], job=kw['job'])# 当然，上面复杂的调用可以用简化的写法：kw = {'city': 'Beijing', 'job': 'Engineer'}person('Jack', 24, **kw)"""## 参数组合# 在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，# 或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。# 比如定义一个函数，包含上述4种参数："""def func(a, b, c=0, *args, **kw):    print 'a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw# 在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。func(1, 2)func(1, 2, c=3)func(1, 2, 3, 'a', 'b')func(1, 2, 3, 'a', 'b', x=99)# 最神奇的是通过一个tuple和dict，你也可以调用该函数：args = (1, 2, 3, 4)kw = {'x': 99}func(*args, **kw)# 所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。"""小结Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！要注意定义可变参数和关键字参数的语法：*args是可变参数，args接收的是一个tuple；**kw是关键字参数，kw接收的是一个dict。以及调用函数时如何传入可变参数和关键字参数的语法：可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。""""""递归函数一个函数在内部调用自身本身，这个函数就是递归函数"""# fact(n) = n! def fact(n):	if n==1:		return 1	return n*fact(n-1)print fact(5)"""尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中："""def fact(n):    return fact_iter(n, 1)def fact_iter(num, product):    if num == 1:        return product    return fact_iter(num - 1, num * product)print fact(5)### 高级特性# 构造一个1, 3, 5, 7, ..., 99的列表，可以通过循环实现：L = []n = 1while n <= 99:    L.append(n)    n = n + 2print n## 切片# 取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下：L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']# 取前3个元素，应该怎么做？笨办法：print [L[0], L[1], L[2]]# 循环r = []n = 3for i in range(n):	r.append(L[i])print r# 对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。# 对应上面的问题，取前3个元素，用一行代码就可以完成切片：print L[0:3]	# 切片  表示，从索引0开始取，直到索引3为止，但不包括索引3## 迭代# 在Python中，迭代是通过for ... in来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的# Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。# list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，# 比如dict就可以迭代# 迭代keyd = {'a': 1, 'b': 2, 'c': 3}for key in d:	print key# 迭代valuefor value in d.itervalues():	print value# 同时迭代key和valuefor k, v in d.iteritems():	print k,':',v# 通过collections模块的Iterable类型判断是否为可迭代对象from collections import Iterableprint isinstance('abc', Iterable) # str是否可迭代print isinstance([1,2,3], Iterable) # list是否可迭代print isinstance(123, Iterable) # 整数是否可迭代# Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：for i, value in enumerate(['A', 'B', 'C']):	print i, value# 上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：for x, y in [(1, 1), (2, 4), (3, 9)]:	print x, y"""小结任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。"""### 列表生成式# 列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。# 举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用range(1, 11)：print range(1, 11)# 如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：L = []for x in range(1, 11): 	L.append(x * x)print L# 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的listprint [x * x for x in range(1, 11)]# 写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，# for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：print [x * x for x in range(1, 11) if x % 2 == 0]# 还可以使用两层循环，可以生成全排列：print [m + n for m in 'ABC' for n in 'XYZ']# 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：import os # 导入os模块，模块的概念后面讲到print [d for d in os.listdir('.')] # os.listdir可以列出文件和目录# for循环其实可以同时使用两个甚至多个变量，比如dict的iteritems()可以同时迭代key和value：d = {'x': 'A', 'y': 'B', 'z': 'C' }for k, v in d.iteritems():	print k, '=', v# 因此，列表生成式也可以使用两个变量来生成listd = {'x': 'A', 'y': 'B', 'z': 'C' }print [k + '=' + v for k, v in d.iteritems()]# 最后把一个list中所有的字符串变成小写：L = ['Hello', 'World', 'IBM', 'APPLE']print [s.lower() for s in L]## 小结# 运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。# 思考：如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，所以列表生成式会报错：# L = ['Hello', 'World', 18, 'APPLE', None]# print [s.lower() for s in L]# 使用内建的isinstance函数可以判断一个变量是不是字符串：x = 'abc'y = 123print isinstance(x, str)print isinstance(y, str)# 修改列表生成式，通过添加if语句保证列表生成式能正确地执行。### 生成器# 如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？# 这样就不必创建完整的list，从而节省大量的空间。# 在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。# 要创建一个generator，有很多种方法# 第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generatorprint [x * x for x in range(10)]print (x * x for x in range(10))# 创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。# 我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？# 如果要一个一个打印出来，可以通过generator的next()方法：print  (x * x for x in range(10)).next() # 每次只计算一次# 使用迭代g = (x * x for x in range(10))for n in g:	print n"""所以，我们创建了一个generator后，基本上永远不会调用next()方法，而是通过for循环来迭代它。generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：1, 1, 2, 3, 5, 8, 13, 21, 34, ...斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易："""def fib(max):    n, a, b = 0, 0, 1    while n < max:        print b        a, b = b, a + b        n = n + 1fib(10)# 仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，# 可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。# 也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，# 只需要把print b改为yield b就可以了：def fib(max):    n, a, b = 0, 0, 1    while n < max:        yield b        a, b = b, a + b        n = n + 1fib(8)# 这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，# 那么这个函数就不再是一个普通函数，而是一个generator# 这里，最难理解的就是generator和函数的执行流程不一样。# 函数是顺序执行，遇到return语句或者最后一行函数语句就返回。# 而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，# 再次执行时从上次返回的yield语句处继续执行。# 举个简单的例子，定义一个generator，依次返回数字1，3，5：def odd():    print 'step 1'    yield 1    print 'step 2'    yield 3    print 'step 3'    yield 5o = odd()o.next()""" 小结要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。"""